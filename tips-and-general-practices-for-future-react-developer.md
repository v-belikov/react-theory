# Советы и общие практики для будущего React разработчика

### Введение:

Прежде всего ты познакомишься с __*тремя основными проблемами*__, с которыми сталкивается каждый React разработчик на
своём пути. Знать эти проблемы важно, так как если ты будешь знать и осознавать эти самые проблемы, то в будущем тебе
будет проще их не допускать. Также в будущем это будет полезно при разработке компонент и организации проекта.

Затем ты узнаешь, какие знания требуется для прочно фундамента.

Следом немного кода и советов на будущее.

### Содержание:

- [*Три основные проблемы, с которыми сталкиваются React
  разработчики*](#Три-основные-проблемы,-с-которыми-сталкиваются-React-разработчики)
  - [Удобство в обслуживании и поддержке компонент](#удобство-в-обслуживании-и-поддержке-компонент)
  - [Глубокое понимание React](#глубокое-понимание-React)
  - [Масштабируемость](#масштабируемость)
- [*Фундаментальные знания, которыми должен обладать каждый React
  разработчик*](#фундаментальные-знания-которыми-должен-обладать-каждый-react-разработчик)
- [*Разбираемся, как создавать чистые, производительные и поддерживаемые React
  компоненты*](#разбираемся-как-создавать-чистые-производительные-и-поддерживаемые-react-компоненты)
  - [Создавай хорошую структуру папок](#cоздавай-хорошую-структуру-папок)
  - [Поддерживай структурированный порядок импортов](#поддерживай-структурированный-порядок-импортов)
  - [Изучи различные шаблоны компонентов](#изучи-различные-шаблоны-компонентов)
  - [Используй линтер и следуй настроенным правилам](#используй-линтер-и-следуй-настроенным-правилам)
  - [Старайся писать тесты для своего кода](#старайся-писать-тесты-для-своего-кода)
  - [Используй TypeScript](#используй-typescript)
  - [Используй ленивую загрузку для грамотного разделения кода](#используй-ленивую-загрузку-для-грамотного-разделения-кода)
  - [Извлекай повторно используемую логику в пользовательские хуки](#извлекай-повторно-используемую-логику-в-пользовательские-хуки)
  - [Сохраняй уникальность key](#сохраняй-уникальность-key)
- [*Советы, которые могут пригодиться для написания хорошего
  кода*](#советы-которые-могут-пригодиться-для-написания-хорошего-кода)
  - [Не используй большое количество пропсов](#не-используй-большое-количество-пропсов)
  - [Используй хук useReducer вместо большого количества useState](#используй-хук-usereducer-вместо-большого-количества-usestate)
  - [Используй сокращение для логических пропсов](#используй-сокращение-для-логических-пропсов)
  - [Избегай фигурных скобок для строковых пропсов](#избегай-фигурных-скобок-для-строковых-пропсов)
  - [Извлекай пропсы, отличные от HTML аттрибутов, при использовании spread оператора на React элементе](#извлекай-пропсы-отличные-от-html-аттрибутов-при-использовании-spread-оператора-на-react-элементе)
  - [React фрагмент вместо div](#react-фрагмент-вместо-div)
  - [Используй самозакрывающиеся теги, когда дочерние элементы не нужны](#используй-самозакрывающиеся-теги-когда-дочерние-элементы-не-нужны)
  - [Следуй общим соглашениям об именовании](#следуй-общим-соглашениям-об-именовании)
  - [Очищай свой код, чтобы предотвратить XSS атаки](#очищай-свой-код-чтобы-предотвратить-xss-атаки)

---

### Три основные проблемы, с которыми сталкиваются React разработчики

#### Удобство в обслуживании и поддержке компонент

Все это выливается из желания __переиспользовать__ одну и ту же компоненту как можно больше раз. Когда приложение
находится на раннем этапе и его компоненты очень легкие, его легко поддерживать. Но, как только добавляются всё
новые и новые «фичи», компоненты начинают разрастаться и тем самым ухудшая простоту их обслуживания, и поддержки в
будущем.

Компонента, которая имеет какую-то общую визуальную часть (UI) и в зависимости от какого-либо условия дополнительный
визуал, начинает разрастаться и усложняться тернарными операторами, простыми && операторами или просто
огромным конструкциями switch.

Например:

1. Условная визуализация - показать тот или иной UI, в зависимости от условия;
2. Имена классов по условию - применить тот или иной набор классов в зависимости от условия;

В этом нет ничего плохого. Но каждый React разработчик должен развить в себе чувство замечать, когда компонент начинает
быть сложным в понимании, когда поддерживать его становится всё труднее и труднее, а также тогда, когда условными
операторами злоупотребляют.

> _**То есть проблема заключается в том, что чем сложнее и различнее результаты компоненты
> ([полиморфизм](https://habr.com/ru/company/ruvds/blog/665290/#anchorid8)), тем сложнее его поддерживать.**_

Честно говоря, основной причиной часто является лень, недостаток опыта или нехватка времени для правильного рефакторинга
компоненты, чтобы сделать его простым в обслуживании и более чистым.

Ещё один ключевой фактор в поддержке - отсутствие или недостаточное тестирование. Чуть больше об этой теме будет ниже.

#### Глубокое понимание React

Ещё одна проблема, с которой сталкивается React разработчик - плохое базовое понимание того, как React работает «под
капотом».

Причина этой проблемы заключается в том, что зачастую начинающий React разработчик перескакивает раздел с базовыми
понятиями и концепциями, переходя сразу к промежуточным или продвинутым. Но это относится не только к React
разработчикам. Это общая проблема в программировании.

> _**Отсутствие четкого понимания «как работает React» может вызвать проблемы в будущем.**_

#### Масштабируемость

Данная проблема тесно переплетается с первой. Это относится не только к React, но и к программному обеспечению в целом.

Создание хорошего программного обеспечение - это не только UX, чистые шаблоны проектирования и продуманная архитектура.
Хорошее программное обеспечение должно также хорошо масштабироваться под новые требования.

> _**Придерживаясь «удобства в обслуживании» и «масштабируемости» при организации компонент и структуры проекта,
разработчик с меньшей вероятностью столкнётся с беспорядком исходного кода, который будет нуждаться в серьёзном
рефакторинге.**_
---

### Фундаментальные знания, которыми должен обладать каждый React разработчик

Что такое **фундамент**? Например, в сфере строительства фундамент - строительная несущая конструкция, часть здания,
сооружения, которая воспринимает все нагрузки от вышележащих конструкций и распределяет их по основанию.
То же самое и с программированием. Начинающий разработчик не сможет построить небоскрёб на песчаном **фундаменте** и
ожидать, что он будет прочным.

Зачастую многие начинающие разработчики сразу перескакивают на промежуточные или продвинутые концепции React без
понимания основ. Это также справедливо и для JavaScript в целом. Поэтому, не имея прочных знаний в JavaScript, нет
смысла начинать изучать React. Вот примерный перечень того, что нужно знать, прежде чем приступать к изучению React:

- Колбэки (Callback Functions);
- Промисы (Promises);
- Методы массива (forEach, map, find, filter, reduce и так далее);
- Деструктуризация массивов и объектов;
- «Rest» и «Spread» операторы;
- Умение использовать new Set() для создания набора уникальных значений;
- Динамические ключи объекта;
- Необязательная цепочка (Optional chaining);
- Fetch API и работа с ошибками;
- Async/Await;

Подробнее об этом можно прочитать [здесь](/js/theory/basic-js-methods-and-concepts.md).

> Также неплохо знать, как работает [замыкание](https://learn.javascript.ru/closure) и
> [каррирование](https://learn.javascript.ru/currying-partials).

Нужно стараться понять, как React работает «под капотом», при его изучении. Эти знания помогут сэкономить много времени
на отладку приложения, так как придётся реже (а может и вовсе не придётся) лазить в документацию или на тот же stackoverflow.com,
в поисках ответов на ту или иную проблему/ошибку.

Однако на начальных этапах понять и узнать всё - сложно, поэтому не стоит переживать из-за этого. По мере решения всё
большего количества практических задач и создания новых проектов, будет приходить то самое понимание.

Начинать изучать React лучше всего с официальной документации, а именно с этой главы - [Основные
понятия](https://ru.reactjs.org/docs/hello-world.html). Все темы этой главы - это тот самый минимум, который начинающий
React разработчик должен усвоить в первую очередь.

Ещё одна глава, которую также необходимо хорошо изучить и разобраться -
[Хуки](https://ru.reactjs.org/docs/hooks-intro.html), так как это уже стандарт и используются они повсюду, особенно в
сторонних пакетах для React.

Также рекомендуется прочитать просто для ознакомления главу [Продвинутые
темы](https://ru.reactjs.org/docs/accessibility.html). Зачастую более сложные темы проще понять, имея практический опыт.
Но чем больше из продвинутых вещей удастся понять на ранней стадии, тем лучше.

Не стоит ограничиваться только документацией. Можно искать статьи или курсы по React. Всё это будет хорошей основой для
будущего **фундамента**, а возможно и целого небоскрёба.

Наиболее важные концепции, которые как минимум нужно знать и понимать:

- Что такое состояние (state);
- Различия между классовыми и функциональными компонентами;
- Что такое ререндеринг компоненты(ов) и как он работает;
- Как запустить процесс ререндеринга;
- Жизненные циклы компоненты и различия между ними;
- Виртуальный DOM;
- Различия между контролируемой и не контролируемой компонентой;
- Подъём состояния (State Lifting);
- Понимание какой-либо технологии управления состоянием (Effector, Redux, Redux Toolkit, Redux Toolkit Query);
- Шаблоны компонентов (HOC, Provider, Compound, Presentational, Container), особенно понимание того, как выбрать
  правильный шаблон;

### Разбираемся, как создавать чистые, производительные и поддерживаемые React компоненты

Мне хочется верить, что мечта каждого программиста - это писать чистый и производительный код. Для меня эта способность
отличает хорошего программиста от великого программиста, и, самое интересное, прокачивать это умение - путь длиною в
жизнь, ведь всегда есть чему поучиться и что-то улучшить.

Следование рекомендациям, что будут ниже, упрощают работу программиста в целом, а особенно в команде.

> Хорошей практикой командной работы - создавать «руководство по стилю кода» или же «Style Guide». В нём команда
> определяет краеугольные камни того, как они пишут код. Например:
> - использовать функциональные компоненты
> - не использовать инлайновые стили
> - поддерживать правильную структуру импорта (сначала импорты сторонних пакетов, затем внутренние импорты и т.д.)
> - не использовать export default
> - и т.д.
>
> Это руководство может быть очень большим, всё зависит от команды. В целом это хороший способ изложить и поддерживать
> лучшие практики и убедиться в том, что твоя команда находится с тобой на одной волне в некоторых важных областях. Все
> это значительно повышает эффективность командной работы и производительность.

А теперь переходим к рекомендациям.

#### Создавай хорошую структуру папок

Организация файлов и папок внутри проекта React является обязательной для «удобства в обслуживании» и
«масштабируемости». **Хорошая** структура папок зависит от размера самого приложения и команды. Поэтому единого
ответа на вопрос нет. Это очень скользкая тема, которая также может зависеть от личных предпочтений.

От себя могу посоветовать присмотреться к [данной](https://feature-sliced.design/ru/) методологии. Вдруг она тебя
зацепит, и ты захочешь следовать ей. Правда, для старта она может быть слегка трудноватой. Поэтому для начала можешь
найти на просторах интернета что-то попроще, например
[эту](https://www.taniarascia.com/react-architecture-directory-structure). Единственно, что мне в примере не
нравится, - это PascalCase для именования папок и файлов, но это уже зависит от твоих личных предпочтений и предпочтений
членов твоей команды.

#### Поддерживай структурированный порядок импортов

Если ты уже имел дело с React, возможно ты встречал файлы, в которых было множество импортов. Зачастую все эти импорты
скомканы вместе: перемешаны импорты с внешних библиотек с внутренними. Например:

```typescript
import React, { useState, useEffect, useCallback } from 'react';
import Typography from '@material-ui/core/Typography';
import Divider from '@material-ui/core/Divider';
import { Title } from '../components/title';
import { Navigation } from '../components/navigation';
import DialogActions from '@material-ui/core/DialogActions';
import { getServiceURL } from '../../utils/getServiceURL';
import Grid from '@material-ui/core/Grid';
import { Paragraph } from '../components/paragprah';
import { sectionTitleEnum } from '../../constants';
import { useSelector, useDispatch } from 'react-redux';
import Box from '@material-ui/core/Box';
import axios from 'axios';
import './styles.scss';
import { DatePicker } from '@material-ui/pickers';
import { Formik } from 'formik';
import { CustomButton } from '../components/customButton';
```

Догадался уже в чём дело? :wink: Трудно различить, что из этого сторонний, а что локальный (внутренний) импорт. Они не
сгруппированы и импортируются отовсюду. Вот как можно было бы сгруппировать:

```typescript
import React, { useState, useEffect, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Formik } from 'formik';
import axios from 'axios';
import Typography from '@material-ui/core/Typography';
import Divider from '@material-ui/core/Divider';
import DialogActions from '@material-ui/core/DialogActions';
import Grid from '@material-ui/core/Grid';
import Box from '@material-ui/core/Box';
import { DatePicker } from '@material-ui/pickers';

import { Title } from '../components/title';
import { Navigation } from '../components/navigation';
import { getServiceURL } from '../../utils/getServiceURL';
import { Paragraph } from '../components/paragprah';
import { sectionTitleEnum } from '../../constants';
import { CustomButton } from '../components/customButton';

import './styles.scss';
```

Теперь структура более понятно, не так ли? :smirk:

Чтобы каждый раз не делать это руками, можно настроить ESLinter и он будет это делать за
тебя. [Вот](https://dev.to/otamnitram/sorting-your-imports-correctly-in-react-213m) неплохая статья о том, как можно
настроить ESLinter для React приложения, чтобы поддерживать выбранную структуру импортов.

#### Изучи различные шаблоны компонентов

Чтобы по итогу не получить неподдерживаемый и не масштабируемый спагетти-код, необходимо изучать различные шаблоны
компонентов по мере того, как будет наращиваться опыт в React.

Но это ещё не все. Знать их - это хорошо, но самое главное уметь их применять, то есть знать, когда какой шаблон должен
использоваться для той или иной проблемы.

Каждый шаблон служит определенной цели. Например, шаблон **compound component** позволяет избежать ненужной
передачи одного пропса до компоненты, которая находится, к примеру, на пять уровней ниже от родителя, то есть
_prop-drilling_. Следует избегать более двух уровней передачи пропса(ов).

> Все это повышает эффективность разработчика и делает компоненты более удобными для поддержки и масштабируемыми.
> Наличие знаний и умений их различать и применять - это то, что различает слабого React разработчика от сильного.

#### Используй линтер и следуй настроенным правилам

Линтер не только помогает поддерживать четкий порядок импортов, о котором было сказано выше, но и помогает
писать код чище и в едином стиле. Это особенно важно, когда над проектом трудится целая команда. А ещё хорошо, когда
линтер настроен для поддержки выбранного «Style Guide» команды.

При создании React приложения через create-react-app, ESLint уже настроен, но его также можно расширять под свои нужды.

ESLint в основном анализирует JavaScript или TypeScript код, который пишет разработчик, указывая ему на ошибки согласно
правилам. Некоторые ошибки могут казаться чисто стилистикой кода, например, пустая строка перед return. А некоторые ошибки
могут указывать на то, что код и вовсе не соберется.

Правила ESLint можно отключать для всего файла или конкретной строки кода. Это имеет смысл, когда по-другому никак,
но такие случаи довольно редкие, поэтому не стоит злоупотреблять отключением правил.

> Также существуют линтеры для проверки css/scss.

#### Старайся писать тесты для своего кода

Писать тесты нравится далеко не всем разработчикам. Многие считают, что это бесполезная трата времени и они не нужны
вовсе. Да, в краткосрочной перспективе это верно, но в долгоиграющей, особенно когда приложение разрастается, тесты это
**must have**.

Тестирование позволяет разработчику гарантировать высокое качество продукта, над которым он трудится, и тем самым
показать заказчику свой уровень профессионализма.

Многие предпочитают полагаться на ручное тестирование. По типу: добавил новую фичу -> потыкал её -> убедился, что она
работает -> отправил в продакшн -> ушёл за очередной порцией вкусняшек, чтобы отметить свой успех... Но далеко не все
учитывают тот факт, что при вводе новой фичи текущий код может сломаться. Даже если разработчик позаботился об этом и
проверил все пересечения текущего кода с новой фичой, это ещё ничего не значит. Также на такое тестирование может уйти
гораздо больше времени, нежели проверить только новую фичу. И никто не застрахован от человеческого фактора и права на
ошибку.

Тесты могут служить своего рода документацией для нового разработчика, который плохо будет знаком с кодовой базой
проекта. При помощи их он сможет разобраться, как работает тот или иной участок кода.

> Поэтому не стоит избегать тестирования только из-за того, что это кажется какой-то ненужной, дополнительной работой.
> В документации React есть небольшая глава по [тестированию](https://ru.reactjs.org/docs/testing.html).

#### Используй TypeScript

До недавнего времени многих React разработчиков отпугивал TypeScript, видя в нём не преимущество, а скорее препятствие,
которое замедляет их работу. Сейчас же многие заказчики требуют, чтобы на проекте использовался TypeScript. Но и тут те
самые разработчики нашли способ особо себя не утруждать. Вместо четких контрактов и всей мощности TypeScript, они
предпочли использовать везде any и им этого было достаточно, а некоторым этого достаточного и по сей день.

> Использование TypeScript имеет много преимуществ, таких как статическая проверка типов, улучшение работы разработчика
> и обнаружение ошибок в типизации во время написания кода - и это лишь малая часть. Более подробно о том, почему стоит
> использовать TypeScript в React приложениях, можно посмотреть вот
> [тут](https://blog.bitsrc.io/5-strong-reasons-to-use-typescript-with-react-bc987da5d907).

Поверь, после того, как ты пересилишь себя перейти с ванильного JavaScript на TypeScript, вернуться назад будет
**оооооооочень** тяжело.

#### Используй ленивую загрузку для грамотного разделения кода

Большинство React приложений собираются в бандлы при помощи таких инструментов как Webpack, Rollup и прочие. В принципе
это правильно, но с ростом приложения начинают возникать проблемы. Бандлы начинают быть "тяжёлыми", что сказывается на
загрузке и скорости работы приложения.

Чтобы избежать подобных проблем, существует метод под названием «Code-Splitting» или же разделение кода, при котором
происходит разбивка общего бандла на более мелкие части кода. Этот метод поддерживается наиболее распространёнными
инструментами, такими как Webpack или Rollup.

Разделенные куски кода можно подгружать лениво, то есть только то, что действительно необходимо пользователю приложения
в данный момент.

> К примеру, если человек пошёл в магазин, чтобы купить бананов, яблок и хлеба. В этом случае ему ведь
> не нужно купить весь ассортимент магазина, а затем из него взять только бананы, яблоки и хлеб. Его интересуют
> конкретные продукты, так зачем покупать всё подряд? Это займёт намного больше времени и обойдётся дороже.

Более подробно об этом можно узнать из [официальной документации по
React](https://ru.reactjs.org/docs/code-splitting.html)

> Так же вместо стандартных инструментов React для разделения кода, можно воспользоваться библиотекой
> [React Loadable](https://www.npmjs.com/package/react-loadable).

#### Извлекай повторно используемую логику в пользовательские хуки

Согласно документации React

> Хуки позволяют нам повторно использовать логику с отслеживанием состояния без изменения иерархии компонентов.

Отсюда можно сделать вывод: всякий раз, когда присутствует кусок кода с отслеживанием состояния, который уже
используется в какой-либо другой компоненте, самое время вынести эту логику в пользовательский хук. Внутри него
инкапсулируется логика и затем используется как обычная функция внутри компонентов, где эта логика необходима.

Больше информации можно получить, прочтя [данную главу](https://ru.reactjs.org/docs/hooks-custom.html) официальной
документации React.

#### Сохраняй уникальность key

При отображении массива данных в виде React элементов или React компонентов нужно всегда определять пропс **key**
(ключ).

Обычная практика, которая зачастую встречается, - использовать в качестве ключа индекс массива. Это на самом деле плохо.

Ключи помогают React определять, какой именно элемент был удален или обновлен. Например, при обновлении запустит механизм
ререндеринга только для элемента, который был обновлен, а не для всего, что находится в массиве. Именно поэтому их
уникальность очень важна.

Пример:

```jsx
const SeasonScores = ({ seasonScoresData }) => (
        <>
          <h3>Our scores in this season:</h3>
          {seasonScoresData.map((score, index) => (
                  <div key={index}>
                    <p>{score.oponennt}</p>
                    <p>{score.value}</p>
                  </div>
          ))}
        </>
);
```

В пределах этого массива индекс является уникальным. Ну а что будет, если компонента будет иметь более одного map?

```jsx
const SeasonScores = ({ seasonScoresData, currentRoster }) => (
        <>
          <h3>Our scores in this season:</h3>
          {seasonScoresData.map((score, index) => (
                  <div key={index}>
                    <p>{score.oponennt}</p>
                    <p>{score.value}</p>
                  </div>
          ))}

          <h3>Our current roster:</h3>
          {currentRoster.map((player, index) => (
                  <div key={index}>
                    <p>{player.name}</p>
                    <p>{player.position}</p>
                    <p>{player.jerseyNumber}</p>
                    <p>{player.totalGoals}</p>
                  </div>
          ))}
        </>
);
```

Теперь у нас ключи не будут уникальными. Предположим, что длина массива seasonScoresData равна 14, в то же время длина
currentRoster равна 30. Как результат, ключи от 0 до 13 не будут являться уникальными. Это может привести к потенциальным
проблемам как с правильностью отображения данных пользователю, так и с неэффективностью обновления DOM-дерева и общей
производительностью приложения.

Чтобы избежать этого поведения, нужно **ВСЕГДА** использовать уникальный ключ. А ещё лучше уникальный ключ **во всем
приложении**. В случае если элементы массива не обладают каким-либо уникальным идентификатором (например, id), то
можно воспользоваться внешней библиотекой, например, [uuid](https://www.npmjs.com/package/uuid), использовав v4 в
качестве генератора.

Предположим, что каждый элемент массива имеет свой личный идентификатор (id), то получим следующий код:

```jsx
const SeasonScores = ({ seasonScoresData, currentRoster }) => (
        <>
          <h3>Our scores in this season:</h3>
          {seasonScoresData.map((score, index) => (
                  <div key={score.id}>
                    <p>{score.oponennt}</p>
                    <p>{score.value}</p>
                  </div>
          ))}

          <h3>Our current roster:</h3>
          {currentRoster.map((player, index) => (
                  <div key={player.id}>
                    <p>{player.name}</p>
                    <p>{player.position}</p>
                    <p>{player.jerseyNumber}</p>
                    <p>{player.totalGoals}</p>
                  </div>
          ))}
        </>
);
```

> Больше информации об этом можно почерпнуть из
> [этой](https://medium.com/swlh/understanding-the-importance-of-the-key-prop-in-react-f2b92ce65f45) статьи.
> Также советую посмотреть [это](https://www.youtube.com/watch?v=OtAlPwW8DNU) видео.

Индекс в качестве ключа можно использовать только в том случае, когда все эти условия являются истиной:

1. список и элементы статичны - они не вычисляются и не меняются;
2. элементы в списке не имеют уникальных идентификаторов;
3. список никогда не переупорядочивается и не фильтруется;

### Советы, которые могут пригодиться для написания хорошего кода

Благодаря предыдущим главам можно заложить прочный фундамент своих знаний и возвести стены. Текущая, и завершающая, глава
послужит прочной крышей, этакой вишенкой на торте.

#### Не используй большое количество пропсов

Максимальное количество пропсов на одну компоненту не должно превышать семи. Если пропсов становится сильно много,
значит стоит задуматься о дроблении на более мелкие компоненты.

#### Используй хук useReducer вместо большого количества useState

Одним из наиболее часто используемых хуков в React является **useState**. Поэтому зачастую можно увидеть нечто подобное:

```jsx
const CustomersMap = () => {
  const [isDataLoading, setIsDataLoading] = useState(false);
  const [customersData, setCustomersData] = useState([]);
  const [hasError, setHasError] = useState(false);
  const [isHovered, setIsHovered] = useState(false);
  const [hasMapLoaded, setHasMapLoaded] = useState(false);
  const [mapData, setMapData] = useState({});
  const [formData, setFormData] = useState({});
  const [isBtnDisabled, setIsBtnDisabled] = useState(false);

  // ...

  return null;
}
```

Наличие большого количества различных хуков useState всегда свидетельствует о том, что размер, а следовательно, и
сложность текущего компонента начинают увеличиваться.

Если ещё в примере выше можно было бы избавиться от последних двух стейтов и вынести вместе с JSX формы в отдельную
компоненту, то бывают случаи, когда разбить компонент на более мелкие не выходит. В таком случае лучше воспользоваться
хуком useReducer.

В официальной документации сказано следующее:

> useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, которая включает в себя несколько
> значений, или когда следующее состояние зависит от предыдущего. useReducer также позволяет оптимизировать
> производительность компонентов, которые запускают глубокие обновления, [поскольку вы можете передавать dispatch вместо
> колбэков](https://ru.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down).

С useReducer пример выше мог бы выглядеть вот так:

```jsx
// INITIAL STATE
const initialState = {
  isDataLoading: false,
  customerData: [],
  hasError: false,
  isHovered: false,
  hasMapLoaded: false,
  mapData: {},
  formdata: {},
  isBtnDisabled: false
}

// REDUCER
const reducer = (state, action) => {
  switch (action.type) {
    case 'POPULATE_CUSTOMER_DATA':
      return {
        ...state,
        customerData: action.payload
      }
    case 'LOAD_MAP':
      return {
        ...state,
        hasMapLoaded: true
      }
          // прочии cases c экшенами
    default:
      return state

  }
}

// COMPONENT
const CustomersMap = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  const someHandler = () => {
    dispatch({ type: 'POPULATE_CUSTOMER_DATA', payload: {} });
  };


  return null;
}
```

> Используя TypeScript типы (action.type) экшенов, можно было бы вынести в отдельный enum.

Теперь компонент выглядит более чистым и обладает некоторыми большими преимуществами, как и говорится в документации
React. _useReducer очень похож на reducer из Redux_.

По-хорошему, в компоненте **не должно быть более четырёх** useState. Также если само состояние сложнее примитивного
типа, например, если хранится объект формы с некоторой глубокой вложенностью.

#### Используй сокращение для логических пропсов

Когда требуется передать значение для логического пропса, некоторые разработчики делают это так:

```jsx
<RegistrationForm hasPadding={true} withError={true} />
```

Если требуется явно передать true, так делать не обязательно, так как наличие самого пропса уже расценивается как true.
Более чистый подход выглядит так:

```jsx
<RegistrationForm hasPadding withError />
```

#### Избегай фигурных скобок для строковых пропсов

Если значение пропса является строкой, его необязательно передавать так:

```jsx
<Paragraph variant={"h5"} heading={"A new book"} />
```

В данном случае фигурные скобки являются overhead'ом, так как тут можно напрямую использовать строки внутри пропса.
Указывая className, следует также пользоваться обычной строкой.

А вот если требуется использовать JavaScript/TypeScript выражение, которое отличается от строки, то тут уже нужно
использовать фигурные скобки. Например, если требуется передать число или объект. Это так же справедливо и для
шаблонного литерала, но увлекаться ими не стоит.

Пример выше должен выглядеть следующим образом:

```jsx
<Paragraph variant="h5" heading="A new book" />
```

#### Извлекай пропсы, отличные от HTML аттрибутов, при использовании spread оператора на React элементе

За базу возьмём этот пример:

```jsx
const MainTitle = ({ isBold, children, ...restProps }) => (
        <h1
                style={{ fontWeight: isBold ? 600 : 400 }}
                {...restProps}
        >
          {children}
        </h1>
);
```

В данном примере имеется компонент, который извлекает некоторые пропсы из всего набора пропсов, а остальные передает их
React элементу через оператор spread. Вроде ничего плохого, но это пока что.

Если мы будем использовать его следующим образом, проблем также не возникнет:

```jsx
// WITH BOLD TITLE
const IndexPage = () => (
        <>
          <MainTitle isBold>
            Welcome to our new site!
          </MainTitle>
          ...
        </>
);

// WITHOUT BOLD TITLE
const AboutPage = () => (
        <>
          <MainTitle>
            Some quick lines about us!
          </MainTitle>
          ...
        </>
);
```

Проблемы могут возникнуть, если начать передавать другие пропсы, которые не извлекаются. Например, если передать пропс
className или id, проблем также не будет, так как они являются HTML аттрибутами.

```jsx
const IndexPage = () => (
        <>
          <MainTitle isBold id="index-main-title" className="align-left">
            Welcome to our new site!
          </MainTitle>
          ...
        </>
);
```

Но если вдруг передать что-то отличное от стандартных HTML аттрибутов, то возникнут проблемки.

```jsx
// Page Component
const IndexPage = () => (
        <>
          <MainTitle isBold hasPadding>
            Welcome to our new site!
          </MainTitle>
          ...
        </>
);

// MainTitle Component
const MainTitle = ({ isBold, children, ...restProps }) => (
        <h1
                style={{
                  fontWeight: isBold ? 600 : 400,
                  padding: restProps.hasPadding ? 16 : 0 // hasPadding так и остался в restProps
                }}
                {...restProps}
        >
          {children}
        </h1>
);
```

Код будет работать, но в браузере, если открыть консоль, будет обнаружена ошибка о том, что hasPadding не является
HTML аттрибутом. Все из-за того, что пропс hasPadding не был извлечён из общего набора пропсов при передаче их h1, как
было сделано с isBold и children.

Чтобы этого избегать, следует всегда извлекать пропсы, которые не являются HTML аттрибутами, если планируется
передавать их React элементу через spread.

Правильный подход должен выглядеть так:

```jsx
// Page Component
const IndexPage = () => (
        <>
          <MainTitle isBold hasPadding>
            Welcome to our new site!
          </MainTitle>
          ...
        </>
);

// MainTitle Component
const MainTitle = ({ isBold, children, hasPadding, ...restProps }) => ( // hasPadding был извлечен
        <h1
                style={{
                  fontWeight: isBold ? 600 : 400,
                  padding: hasPadding ? 16 : 0
                }}
                {...restProps}
        >
          {children}
        </h1>
);
```

С большим количеством информации об этом и некоторых других способах решения этой проблемы можно ознакомиться
[тут](https://ru.reactjs.org/warnings/unknown-prop.html);

#### React фрагмент вместо div

React компонент может помещать в себя только один React компонент или React элемент. Поэтому если попытаться поместить
более одного React компонента или React элемента, то React выдаст ошибку, в которой будет сказано о том, что следует
обернуть их в какой-то общий React элемент.

```jsx
// Will throw an error
const InfoText = () => (
        <h1>Welcome!</h1>
        <p>This our new page, we're glad you're are here!</p>
);
```

Вероятнее всего первой мыслью будет обернуть их в div. Но при использовании div в DOM дереве будет также создан этот
div. Особо смысла в этом нет, если задача была лишь обернуть React элементы для избежания ошибки.

Правильный способ будет - воспользоваться React фрагментом:

```jsx
const InfoText = () => (
        <>
          <h1>Welcome!</h1>
          <p>This our new page, we're glad you're are here!</p>
        </>
);
```

#### Используй самозакрывающиеся теги, когда дочерние элементы не нужны

В React имеется возможность передавать дочерние элементы в компоненту, которые затем становятся доступны для компонента
через пропс children. Такой подход называется композицией компонентов (**composite components**). В таком случае нужно
использовать открывающий и закрывающий теги:

```jsx
<NavigationBar>
  <p>Home</p>
  <p>About</p>
  <p>Projects</p>
  <p>Contact</p>
</NavigationBar>
```

Но если не планируется передавать дочерние элементы, использовать открывающий и закрывающий теги бессмысленно:

```jsx
<NavigationBar></NavigationBar>
```

Вместо этого лучше использовать компонент как самозакрывающийся элемент:

```jsx
<NavigationBar />
```

Так гораздо чище.

#### Следуй общим соглашениям об именовании

Смысл этого соглашения заключается в том, чтобы легче распознавать, какой это тип элемента.

Например, для React компонентов (а также для интерфейсов или псевдонимов типов, если используется TypeScript) принято
использовать PascalCase:

```tsx
// React component
const LeftGridPanel = () => (<h1>some text</h1>);

// Typescript interface
interface AdminUser {
  id: number;
  name: string;
  email: string;
}

// Typescript Type Alias
type TodoList = {
  todos: string[];
  id: number;
  name: string;
}
```

Для типов данных, таких как переменные, массивы, объекты, функции и так далее, принято использовать camelCase:

```jsx
const getLastDigit = () => {
  // некотрая логика
};

const userTypes = ['Admin', 'Viewer'];
```

Именовать React компоненты в PascalCase особенно важно, потому что ESLinter, настроенный для React, будет выдавать
предупреждающее сообщение, если в компоненте в стиле camelCase будут использоваться хуки.

#### Очищай свой код, чтобы предотвратить XSS атаки

У React есть свой аналог innerHTML из JavaScript - dangerouslySetInnerHTML. Таким образом, используя его, можно
устанавливать HTML непосредственно из React.

Рассмотрим пример, в котором разработчик пытается отобразить HTML строку внутри div. Данная строка может быть взята из
текстового редактора, где она уже отформатирована в формате HTML:

```jsx
const Markup = () => {
  const htmlString = "<p>This is set via dangerouslySetInnerHTML</p>"

  return (
          <div dangerouslySetInnerHTML={{ __html: htmlString }}/>
  )
}
```

В названии этого свойства присутствует слово **dangerously** и оно тут не случайно. Использование этого свойства может
открыть уязвимость кода к межсайтовому скриптингу (XSS). Поэтому код, перед тем как его вставить, должен очищаться.

> [DOMPurify](https://www.npmjs.com/package/dompurify) - неплохая библиотека для санитайзинга (очищения кода).
